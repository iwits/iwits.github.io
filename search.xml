<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解ES6-字符串与正则表达式]]></title>
    <url>%2F2019%2F06%2F29%2FUnderstanding_ECMAScript6_String-and-Regular-expression%2F</url>
    <content type="text"><![CDATA[深入理解ES6-字符串与正则表达式 ES6完全支持了Unicode从而让Javascipt能够合理地处理UTF-16字符. ES6为字符串和正则表达时添加了新的方法 ES6新增了一个重要特性-模板字面量,为JavaScript带来多行字符串的内建支持. 过去,现在,将来,一代又一代,直到时间的消失 字符的编码字符集与字符编码 计算机中存储的信息都是使用二进制表示的.将我们熟悉的文字符号以既有的规则(如二进制)表示,这就称之为编码.与其对应的过程称之为解码. 字符集(Charset): 将所有字符汇总起来的集合. 字符编码(Character encoding):是一套规则.使用该规则可以实现自然语言中的一个集合,与其他规则集合(如电脉冲/数字)建立映射关系. 码位(Code Point):全球唯一的标识符,是从0开始的字符 utf-8/utf-16/utf-32早期的计算集使用Ascii码对英文字符进行编码.但是随着计算机的普及发展,使用其他语言的国家为了对自己语言字符进行表达,纷纷推出了自己编码规则(即字符编码).比较典型的有表示简体中的gb2312,表示繁体中文的BIG5. 这种为了适合当地的语言和字符,设计新字符编码规则的做法,在本地使用没有任何问题,但是相 io互访问就会出现乱码现象. 为了解决乱码问题,一个伟大的创想-Unicode诞生了.Unicode是一个字符集,它是基于通用字符集的标准发展而来,所致力的目标位位全世界每一个字符提供全球唯一的标识符,目前已经成为计算机科学领域里的一项业界标准.XML/Java编程语言/现代的操作系统都采用了Unicode字符集.我们常说的utf-8/utf-16/utf-32是针对Unicode字符集的三种字符编码方案. utf-32使用4个字节来表示每一个字符,优点是编码规律(第N个字符一定是从4的N次方个字节开始).但是就空间而言,完全没有效率. Utf-16使用两个字节表示0~65535个字符,65535范围被成为基本多文种平面[BMP, Basic Multilingual Plane])的字符,而对于超出65525范围(辅助平面(supplementary plane))则需要一些特殊的技巧来实现.为此uft-16引入了代理对(surrogate pair),其规定两个16位编码单元表示一个码位. uft-8使用一至四个字节位每个字符编码.是一种针对Unicode的可变长度字符编码(定长码),也是一种前缀码.他可以用来表示Unicode标准中的任何字符,并且其编码的第一个字节仍与ASCII兼容,这使得它逐渐成电子邮件/网页或传输文字的应用中最优先采用的编码.IETF要求所有的互联网协议都必须支持utf-8编码. 这也就是说在utf-16中有两种字符 使用一个编码单元16位表示的BMP字符 使用两个编码单元32位表示的辅助屏幕面字符 值得一提的是,除了多种编码方式,不同操作系统之间的大小字节序也影响着对字节的编码与解码.为了解决这个问题，多字节的Unicode编码方式定义了一个”字节顺序标记(Byte Order Mark)”，它是一个特殊的非打印字符，你可以把它包含在文档的开头来指示你所使用的字节顺序。对于UTF-16，字节顺序标记是U+FEFF。如果收到一个以字节FF FE开头的UTF-16编码的文档，你就能确定它的字节顺序是单向的(one way)的了；如果它以FE FF开头，则可以确定字节顺序反向了。 ES6对utf-16的支持在ES5中,所有的字符串操作都是基于16位编码单元.这时候如果使用对使用了两个编码单元32位表示的字符使用对应的方法,则会导致得到的结果与预期不符合.12345678let text = &quot;𠮷&quot;;console.log(text.length); //2 长度实际位1,但是length位2console.log(/^.$/.test(text)); //false 正则表达式是用来判定单一字符的.因此失效.console.log(text.charAt(0)); //&quot;&quot; 前16位不包含可打印字符console.log(text.charAt(1)); //&quot;&quot; 后16位不包含可答应字符console.log(text.charCodeAt(0)); //55362 charCodeAt()会返回每16个编码单元对应的数值.console.log(text.charCodeAt(1)); //57271 正是因为以上的种种的问题,ES6中强制使用utf-16编码来解决上诉问题,并按照这种字符编码来标准准话字符串操作,在Javascript中增加专门针对代理对的功能. codePointAt()方法ES6新增完全支持UTF-16的codePointAt()方法,这个方法接受的编码单元的位置,而非字符位置作为参数,返回与字符串中给定位置对应的码位,即一个整数值. 123456789let text = &quot;𠮷a&quot;;console.log(text.charCodeAt(0)); //55362 console.log(text.charCodeAt(1)); //57271console.log(text.charCodeAt(2)); //97console.log(text.codePointAt(0)); //134071console.log(text.codePointAt(1)); //57271console.log(text.codePointAt(2)); //97 最佳实践:要检测一个字符占用的编码单元数量,最简单的方法是调用字的codePointAt()方法.12345function is32Bit(c)&#123; return c.codePointAt(0) &gt; oxFFFF;&#125;console.log(is32Bit(&quot;𠮷&quot;)); //trueconsole.log(is32Bit(&quot;a&quot;)); //false String.formCodePoint()方法ES6中提供的String.formCodePoint()方法是codePointAt()的反向方法,用于根据制定码位生成一个字符.1console.log(String.formCodePoint(134071)); normalize()方法Unicode的另一个有趣之处在于,如果我们要对不同字符进行排序或比较操作,会存在一种可能,他们是等效的.所谓的规范等效存在两种情况: 无论从哪个角度来看,两个序列的码位都是没有区别的 两个互相兼容的码位序列看起来不同,但是在特定的条件下可以被互相交换使用.其本质是通过特定的方法把等效标准化. ES6为字符串添加了一个normalize()方法,它可以提供Unicode的标准化形式.这个方法接受一个可选的字符串参数,指明应用以下的Unicode标准化形式. 以标准等价方式分解,然后以标准等价方式重组(‘NFC’), 以标准等价方式分解(‘NFD’) 以兼容等价方式分解(‘NFKC’) 以兼容等价方式分解,然后以标准等价方式重装(‘NFKD’) 最佳实践: 在对比字符串之前一定要先把他们标准化为同一形式.在国际化的开发中应用广泛. 12345678910111213141516171819202122232425262728//对数组中的每一个字符串进行比较let normalize = values.map(function(text)&#123; return text.normalize();&#125;);normalize.sort(function(first, second)&#123; if (first &lt; second)&#123; return -1; &#125; else if (first = second)&#123; return 0; &#125; else &#123; return 1; &#125;&#125;);//比较原始数组values.sort(function(first, second)&#123; let firstNormalized = first.normalize(), secondNormalized = second.normalize(); if(firstNormalized &lt; secondNormalized)&#123; return -1; &#125; else if (firstNormalized = secondNormalized)&#123; return 0; &#125; else &#123; return 1; &#125;&#125;); 正则表达式u修饰符正则表达式是应用非常广泛,有很多好用的在线正则表达式网站.正则表达式默认将字符串的每一个字符按照16位编码单元处理.当遇到32位编码单元时就就出现错误.为了解决这个问题,ES6中引入了正则表达式u修饰符. 当一个正则表达式添加了u修饰符,他就会从编码操作模式切换为字符模式,如此一来正则表达式就不会视代理对为两个字符,从而完全按照预期正常运行. 1234let text = &quot;𠮷&quot;;console.log(text.length); //2console.log(/^.$/.test(text)); //false /^.$/表示匹配所有但字符字符串,没有用U时会匹配编码单元.使用u时会切换到匹配字符模式console.log(/^.$/u.test(text)); //false 虽然ES6中并没有支持字符串码位数量的检测,但是有了u修饰符之后,可以用正则表达式来解决这个问题. 123456function codePointLength(text)&#123; let result = text.match(/[\s\S]/gu); //[\s\S]保证名匹配到新行 return result ? result.length : 0;&#125;console.log(codePointLength(&apos;𠮷bc&apos;)); // 3 最佳实践:因为u修饰符时语法层面的变更,尝试在不兼容ES6的JavaScript引擎中使用它会导致语法错误.如果要检测当前引擎是否支持u修饰符,最安全的方式时通过以下这个函数:1234567891011//代码工作在老式的JavaScript引擎中,那么在使用u修饰符时,切记//要使用RegExp构造函数,这样可以避免发生语法错误,并且可以有选择的//检测和使用u修饰符function hasRegExpU()&#123; try &#123; var pattern = new RegExp(&quot;.&quot;, &quot;u&quot;); return true; &#125; catch (ex)&#123; retun false; &#125;&#125; 其他字符串变更字符串中的子串识别之前的版本中我们一直使用indexOf()方法在一段字符串中检测另一端子字符串,他们一直希望能通过更简单的方法来识别字串. ES6 中增加3个类似的方法可以达到相同的效果. includes()方法,如果在字符串中检测到指定文本则返回true,否则返回false startsWith()方法,如果在字符串的起始部分检测到指定文本则返回true,否则返回false endsWith()方法,如果在字符串的结束部分检测到指定文本则返回true,否则返回false 以上三种方法都支持两个参数(searchText,[startIndex]). 实践注意: 如果需要获得子串在字符串中的实际位置还是得用indexOf()或lastIndexOf() indexOf()或lastIndexOf()的参数中可以传入正则表达式(他们会把正则表达转化为一个字符串并搜索它).但是在以上三个方法中,第一个参数传入正则表达式则会出发一个错误. repeat()方法ES6为字符串增加了repeat()方法,其接受一个number类型的参数,表示该字符串重复的次数,返回值时当前字符串重复一定次数后的新字符串.1console.log(&quot;x&quot;.repeat(3)); //xxx 最佳实践,可以用这个方法来控制缩进 12345let indent = &quot; &quot;.repeat(4), indentLevel =0;//当需要增加缩进的时候let newIndent = indent.repeat(++indentLevel); 其他正则表达式语法变更正则表达式y修饰符 y修饰符曾在Firefox中被实现过,现在经ES6标准化后正式成为正则表达式的一个专有扩展.它会影响正则表达式搜索过程中的sticky属性.当在字符串中开始字符匹配时,他会通知搜索从正则表达式的lastIndex属性开始进行,如果在指定位置没能成功匹配,则停止继续匹配. lastIndex属性指明每次搜索开始的位置 g修饰符从这个位置开始向后搜索直到匹配位置 y修饰符同样遵守lastIndex属性,但是要求必须在lastIndex指定的位置发现匹配.实际上y修饰符隐含了头部匹配的标志^.y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。 当执行操作的时候,y修饰符和g修饰符都会把上一次匹配后面一个字符的索引把偶你在lastIndex中;如果该操作匹配的结果为空,则lastIndex会被重置为0. 1234567891011121314151617181920212223 let text =&quot;hello1 hello2 hello3&quot;, pattern = /hello\d\s?/, result = pattern.exec(text), globalPattern = /hello\d\s?/g, globalResult = globalPattern.exex(text), stickyPattern = /hello\d\s?/y, stickyResult = stickyPattern.exec(text);console.log(result[0]); //&quot;Hello1&quot;console.log(globalResult[0]); //&quot;Hello1&quot;console.log(stickyResult[0]); //&quot;Hello1&quot;pattern.lastIndex = 1;globalPattern.lastIndex = 1;stickyPattern.lastIndex = 1;result = pattern.exec(text);globalResult = globalPattern.exex(text);stickyResult = stickyPattern.exec(text);console.log(result[0]); //&quot;Hello1&quot;console.log(globalResult[0]); //&quot;Hello2&quot;console.log(stickyResult[0]); // 抛出错误 使用y修饰符的时候,还需要记住以下几点: sticky 属性时候只读属性,其值由该修饰符的存在性所决定. 只有调用exec()和test()这些正则表达式对象的方法时才会涉及lastIndex属性;调用字符串的方法,例如match(),则不会触发沾滞行为. 1234//单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。let text = &apos;a1a2a3&apos;;text.match(/a\d/y) // [&quot;a1&quot;]text.match(/a\d/gy) // [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;] 对于沾滞正则表达式而言,如果使用^字符来匹配字符串开端,指挥从字符串的起始位置或多行模式的首行进行匹配. 若要检测y修饰符是否存在,与检测其他正则表达式修饰符类似,可以通过属性名来检测.sticky属性表示是否设置了y修饰符 1234567891011121314//检查sticky属性的存在性let pattern = /hello\d/y;console.log(pattern.sticky); //如果Javasc引擎支持沾滞修饰符,则sticky的属性为true.//检查JavaScript引擎对y修饰符的支持,不支持则会报错.在老浏览器里面运行一定要记得增加判断function hasRegExpY&#123; try&#123; var pattern = new RegExp(&quot;,&quot;, &quot;y&quot;); return true; &#125; catch (ex)&#123; return false; &#125;&#125; g修饰符会忽略非法字符,y修饰符不会,这样容易发现错误. 正则表达式的复制在ES5中可以通过给RegExp构造函数传递正则表达式作为参数来符之这个正则表达式12345678910var rel1 = /ab/i, rel2 = new RegExp(rel1); //在ES5中,此时rel2只是rel1的一份拷贝.但如果给RegExp构造函数提供第二个参数,为正则表达式指定一个修饰符,则代码无法运行. //ES5中报错,ES6中正常运行 rel3 = new RegExp(rel1, &quot;g&quot;); //在ES6 中 console.log(rel1.tostring());// &quot;/ab/i&quot; console.log(rel2.tostring());// &quot;/ab/i&quot; console.log(rel3.tostring());// &quot;/ab/g&quot; flags属性在ES5中如果想获取正则表达式的文本,可以通过source属性,但是如果想获取使用的修饰符,就需要tostring()来获取输出的文本.12345678function getFlags(re)&#123; var text = re.tostring(); return text.substring(text.lastIndexOf(&quot;/&quot;) + 1, text.length);&#125;//tostring()返回值为&quot;/ab/g&quot;var re = /ab/gconsole.log(getFlags(re)); 为了简化这一过程,ES6中使用了flags属性,它与source属性都是制度的原型属性访问器.对其之定义了getter方法,这极大的简化了调试和编写继承代码的复杂度.ES6的版本中,访问flags属性会返回所有应用在当前正则表达式的修饰符字符串.1234let re = /ab/g;console.log(re.source); //&quot;ab&quot;console.log(re.flags); //&quot;g&quot; 模板字面量 模板字面量(前称模板字符串)是允许嵌入表达式的字符串字面量.可以使用多行字符串和字符串插值功能. ES6模板字面量语法支持创建领域专用语言(DSL,通指为某些具体且头衔的目标设计的语言).它比ES5及早期版本中的解决方案更安全. ES6模板字面量这个扩展方案是扩展ECMAScript基础语法的语法糖,其提供一套生成/查询并操作其他自然语言里内容的DSL,并且可以免受注入攻击.例如, XSS, SQL注入等等. 实际上ES5中的方案缺少许多特性,为ES6通过模板字面量的方式进行了填补: 多行字符串 一个正式的多行字符串的概念 基本的字符串格式化 将变量的值嵌入字符串的能力 HTML转义 向HTML插入经过安全转换后的字符串的能力.]]></content>
      <categories>
        <category>前端学习</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>ES6</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ES6-变量作用域]]></title>
    <url>%2F2019%2F05%2F29%2FUnderstanding_ECMAScript6_Variable_Scope%2F</url>
    <content type="text"><![CDATA[深入理解ES6-变量作用域 最佳实践: 默认使用const,只在确实需要改变变量的值的时候使用let。在需要覆盖全局变量的时候使用var 过去,现在,将来,一代又一代,直到时间的消失 最佳实践 默认使用const,只在确实需要改变变量的值的时候使用let。在需要覆盖全局变量的时候使用var。 var声明及Hoisting机制 使用var关键字来声明变量 无论在哪里声明，都会被当成在当前作用域顶部声明的变量 声明提前，初始化操作依旧留在原处执行 块级声明 块级作用域（又称词法作用域），用于声明在指定块的作用域之外无法访问的变量。存在于： 函数内部 块（{}）中 使用let关键字声明块级元素，将变量的作用域限制在当前代码块中 let声明不会提前，因此通常把let声明语句在封闭代码块的顶部 假设当前作用域已存在某个标识符（无论是全局或函数作用域），再次使用块级标识符声明会抛出错误。 const也是块级标识符 块级作用标识符特点是声明不会hoisting，一旦执行到块外就被销毁。 禁止重声明 同一作用域中不能用let重复定义已经存在的标识符。但是如果当前作用域内嵌另一作用域，则可以在内嵌的作用域中使用let声明同名变量。 1234567891011121314//例子1var count = 20;//下面语句会抛出错误let count =40;//例子2var count = 20;if (conditon)&#123; //不会抛出错误，内部作用域的count会屏蔽全局作用域的count let count = 40; Alert(count); //40&#125;Alert(count); //20 const声明 和其他语言一样，const声明的是常量，一旦被设定之后不可修改，每个使用const定义的常量必须进行初始化。一旦不初始化，则会抛出错误。 const和let都是块级作用标识符 假设当前作用域已存在某个标识符（无论是全局或函数作用域），再次使用块级标识符声明会抛出错误。 无论在严格模式还是非严格模式下，都不可以为const定义的常量再赋值。一旦赋值就会抛出错误。 123456789//不能重声明， 被let声明过的不能用const声明var count = 20;let age = 10;const price = 100;//以下语句都会抛出错误const count = 40;const age = 12;let price = 200; const声明不允许修改绑定，但是允许修改值。 1234567891011const person = &#123; name: &quot;Nick&quot;&#125;;//可以修改值person.name = &quot;Greg&quot;;//不可以修改绑定person = &#123; name: &quot;Greg&quot;&#125;; 临界死区（Temporal Dead Zone） 由于声明不会被提前，在作用域外访问变量会抛出错误。即使是相对安全的typeof. Javascript引擎在扫描代码发现变量声明时，要么将它们提升至作用域顶部（var），要么将声明放到TDZ中（let、const）。访问TDZ中的变量会触发运行时错误。只有执行过变量声明语句后，变量才会从TDZ中移出，然后方可访问。 12345console.log(typeof value); // undefinedif (condition) &#123; console.log(typeof value); //引用错误 let value = &quot;blue&quot;;&#125;; 循环中的块级作用域绑定 块级作用域最经典的应用场景就是在循环中，将计数器变量使用块级声明。保证一旦循环结束，，其他地方不可以访问计数器。 循环中的函数 var声明因为变量共享的问题，使得在循环中创建函数非常困难 123456789101112var funcs = [];//var声明的i被共享存储在funcs里面。执行下面操作会输出10个10for (var i = 0; i &lt; 10; i++)&#123; funcs.push(function()&#123; console.log(i); &#125;);&#125;funcs.forEach(function(func)&#123; func(); &#125;); IIFE解决了这个问题，它的思路是通过强制生成计数器变量的副本，规避共享变量。 1234567891011121314var funcs = [];//每次接收到i都创建一个新的副本并存储为value foreach循环调用的时候就会输出0到9for (var i = 0; i &lt; 10; i++)&#123; funcs.push((function(value)&#123; return function() &#123; console.log(value); &#125; &#125;(i)));&#125;funcs.forEach(function(func)&#123; func(); &#125;); ES6支持了块级声明之后，可以使用块级声明达到同样的效果。这是因为块级标识符利用了块级标识符一旦离开了作用域会自动销毁的特性。使用块级标识符声明声明计数器变量，每次循环中都会创建一个新的变量，并以之前循环中同名变量的值将其初始化。【aka.自动副本】 对于for 循环，let和const两种块级标识符是有差别的。 1234567891011121314151617181920212223242526// **********方案一**************** var funcs = []; for (let i = 0; i &lt; 10; i++)&#123; funcs.push(function()&#123; console.log(i); &#125;); &#125; funcs.forEach(function(func)&#123; func(); &#125;); // **********方案二**************** var funcs = []; //完成一次循环之后，会抛出报错。因为i被定义为常量，i++中尝试修改i的绑定，抛出错误 for (const i = 0; i &lt; 10; i++)&#123; funcs.push(function()&#123; console.log(i); &#125;); &#125; funcs.forEach(function(func)&#123; func(); &#125;); 对于for-in或者for-of循环，只要循环中不涉及对计数器变量绑定的修改，表现就是无差异。每次循环都会创建一个新的key绑定，因此每个函数都有一个变量key的副本。于是不同的函数输出不同的值。正是因为每次都会创建一个新的绑定。在不修改计数器变量的请况下。const声明也不会抛出错误。 12345678910111213141516171819202122232425262728293031323334//**************let********* var funcs = [], object = &#123; a: true, b: true, c: true &#125;; for (let key in object)&#123; funcs.push(function()&#123; console.log(key); &#125;); &#125; funcs.forEach(function(func)&#123; func(); &#125;); //************const*********qvar funcs = [], object = &#123; a: true, b: true, c: true &#125;;for (const key in object)&#123; funcs.push(function()&#123; console.log(key); &#125;);&#125;funcs.forEach(function(func)&#123; func(); &#125;); 全局块作用域绑定 块级标识符和var声明另一个很大的区别，在于他们在全局作用域中的行为。 当var被作用域全局作用域的时候，他会创建一个新的全局变量作为全局对象[我们所说的全局对象是window对象]的属性。这意味着var可能会覆盖一个已经存在的全局属性。 在全局作用域下使用块级标识符，则是会在全局作用域下创建一个新的绑定，该绑定不会成为全局对象的一个属性。换句话说，块级作用域不能覆盖全局变量，只能遮蔽它。 如果不想对全局对象创建属性，则使用let和const 要安全。如果希望在全局对象下定义变量，仍然可以使用var。这种情况创建于在浏览器中跨frame或者跨window访问代码。]]></content>
      <categories>
        <category>前端学习</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>ES6</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + GitHub Pages搭建博客教程(附带踩坑+攻略)]]></title>
    <url>%2F2019%2F05%2F04%2FHexo_GitHub_Pages_Build_blog%2F</url>
    <content type="text"><![CDATA[仅以此文记录我自己搭建hexo博客的过程以及踩到的坑. 本地操作系统为为Win10. 使用的hexo版本为3.0后的版本(NexT对其支持较好,2.0+版本未实验) 托管位置:github 过去,现在,将来,一代又一代,直到时间的消失 什么是Hexo? Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 选择Hexo的理由很简单. 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件 支持一键部署 有丰富的插件和主题 Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 内容物为静态网页,可以轻松的托管再GitHub上,管理和更新方便. 什么是Github Pages? Github是世界上最大的代码存放网站和开源社区.Githubpages功能的推出,让用户有机会自定义项目首页,用来替代默认的源码列表.它是一种被用户编写\托管再Github上面的静态网页. 准备工具 “工欲善其事,必先利其器” 工具类安装 下载安装npm 下载并安装Git 下载并安装Node.js Create a new repository 特别提醒:我已经拥有Github账户.如果你没有,请移步官网注册. 这里一定要把项目名字定义成以下样式. 1&#123;username&#125;.github.io 搭建博客本地环境搭建Hexo 本机新建一个文件夹,如blog 进入该文件夹.鼠标右键选择”Git Bash Here”. 1npm install -g hexo-cli 执行上述步骤成功后,输入 1npm install 生成静态页面,启动本地hexo服务进行本机测试.依次执行以下命令 123hexo cleanhexo ghexo server 打开localhost:4000, 测试安装是否成功.看见页面即为成功. 关联到Github Create a New respository 安装Hexo的Git Deployer插件 1npm install hexo-deployer-git --save 本地生成静态文件 12hexo cleanhexo g 将静态文件推送到Github. 1hexo d SSH Key 使用SSH key避免执行Hexo d部署时频繁的密码输入. 测试是否有已存在的SSH key任意位置打开Git Bash 1cd ~/.ssh 本地生成密钥 如果没有,那么我们在本地生成密钥.输入的邮箱是github注册邮箱. 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 根据提示按下三次回车.可以看到以下文字则表示密钥生成成功.(生成的id_rsa.pub文件默认在系统盘个人文件夹下的.ssh文件夹中.) 123 Your identification has been saved in ~/.ssh/id_rsa.Your public key has been saved in ~/.ssh/id_rsa.pub.The key fingerprint is: 设置GitHub项目的deploy Keys,粘贴进去就好了. 测试配置是否成功 1ssh -T git@github.com 出现以下样式的配置则表示成功 12 Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 修改部署协议为SSH 进入blog文件夹,使用记事本类工具打开_config.yml文件,设置deploy属性. 1234 deploy:type: gitrepo: git@github.com:chengjianhua/chengjianhua.github.io.gitbranch: master 设置域名 购买域名(我用的阿里云购买,大家可以根据自己的喜好) 域名备案 设置DNS云解析(域名解析生效需要时间,我直接隔天查看了) 依次进入本地文件夹Blog-&gt;source,新建一个文件名为CNAME 执行”cgd”操作将CNAME文件提交到服务器上 123hexo cleanhexo ghexo d 使用网址访问是否正常. Hexo使用指南(Next)Hexo主题设置(Next) 下载主题我使用的是star数量最多的Next主题,你也可以访问主题列表选择自己喜欢的主题. 进入blog页面,Git Bash here输入以下命令以下载next主题.(我是无脑最新,稳定版下载请访问Next官网查找最新稳定版本) 1git clone https://github.com/iissnan/hexo-theme-next themes/next 下载完成之后,会在\bolg\themes中看到next 文件夹. 找到blog底下的_config.yml文件,修改theme 1theme: next 执行“cgd操作” 提交到服务器.如果你想在本地查看,那执行完cg操作之后,使用 1hexo server 启动本地服务,在浏览器中使用localhost:4000查看本地页面. Next 设置语言 实名感谢Hexo支持中文. 修改blog下的_config.yml文件中的language 语言 代码 English en 简体中文 zh-Hans Français fr-FR Português pt 繁體中文(Hk) zh-hk 繁體中文(tw) zh-tw Русский язык ru 日本語 ja Korean ko Next更多使用说明可以查看Next官网.或者期待我的不定期更新的日常 遇到的坑与解决措施SSH 协议设置不生效SSH协议传输设置最开始使用网上的 1234567891011121314 #切入到包含 .git 文件夹的文件夹 cd .deploy/ #查看当前的传输协议 git remote -v origin https://github.com/USERNAME/REPOSITORY.git (fetch) origin https://github.com/USERNAME/REPOSITORY.git (push)#修改 https 协议为 ssh 协议 git remote set-url origin git@github.com:USERNAME/REPOSITORY2.git#或者 git remote add origin git@github.com:username/username.github.io.gi 然而并没有生效,最后使用了上文所述SSH设置方法,才生效.原因未知,google了以下,也有很多人和我一样. localhost正常,部署后自定义域名访问为404或空白 localhost页面正常,然而部署到github之后页面不是空白就是404 查看github上面的文件,发现index.html文件中都是空白,怀疑是提交插件安装有问题.我重装Git Deployer插件后正常.具体猜测是因为第一次装该插件有依赖包版本不正确.回滚数个版本仍异常,干脆卸载重装,重装后正常. Localhost正常,部署后页面没有无主题样式,只有文字. 看了下页面的html文件,主要是加载的script位置不正确.具体的配置跟blog下的_config.yml有关. 修改期中url与root设置后正常.(切记冒号后要有空格,不然编译出错) 12url: https://github.com/iwits/iwits.github.io/root: /]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>环境搭建</tag>
        <tag>GitHub pages</tag>
        <tag>NextT</tag>
      </tags>
  </entry>
</search>
