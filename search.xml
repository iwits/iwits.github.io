<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解ES-Symbol和Symbol属性]]></title>
    <url>%2F2019-08-24-Understanding-ECMAScript6-Symbol.html</url>
    <content type="text"><![CDATA[symbol 类型从机制上保证了每个属性名字都是独一无二的.这能有效的避免我们使用mixin模式时候,新增方法和现有方法的人冲突. Symbol是JavaScript中的一割新的原始类型,用于创建必须通过Symbol才能引用的属性 Symbol值通过Symbol函数生成 可以为symbol增加描述.在全局作用域中有一个symbol注册表,在代码的不同位置,总是可以通过相同的描述字符串获取到同一个symbol,从而可以共享symbol. ES6中提供了Object.getOwnProperty-Symbols(),来检索symbol属性 过去,现在,将来,一代又一代,直到时间的消失 为什么需要Symbol属性?我们在使用mixin模式的时候,很容易出现新增属性名与现有属性名冲突的情况.如果有一种计制,能够保证每个属性名都是独一无二的,这样就能从根源上解决冲突的问题.这就是Symbol类型出现的原因. ES6开始引入Symbol作为一种原始类型.(原始类型: 字符串型\数字型\布尔型\Null\Undefined\Symbol) 创建Symbol创建的语法所有的原始值除了symbol都有自己的字面形式.Symbol值通过Symbol函数创建 123456let firstname = Symbol();let person = {};person[firstname] = 'nick';console.log(person[firstname]); //"nick"typeof firstname ;''//"symbol" Symbol因为是原始值,所以不能使用new来调用,否则会程序报错.此外Symbol值不是对象,不能添加属性. 本质上来说Symbol是一种类似string的数据类型. Symbol()接受一个可选参数传入一段文本描述.这段描述不可以用于属性访问.但是建议创建的时候都加上,增加代码可读性. 1234let s = Symbol('Test string');//这里是隐式的调用了toString()console.log(s);//"Test string" Symbol的描述被存储在内部的[[Description]]属性之中,只有调用Symbol的同String()方法的时候,才可以读取这个属性. 作为属性名的symbol12345678910111213141516let mySym = Symbol();//No.1let a = {};a[mySym] = "hi";//No.2let a ={ [mySym]: "Hi";};//No.3let a = {};Object.defineProperty(a, mySym, {value: "hi"});//以上写法a[mySym];//"hi" 需要注意的是: 当Symbol作为对象属性名的时候,是不可以使用点运算符的(.) Symbol值作为属性名的时候,该属性是公开属性,不是私有属性 Symbol的使用方法所有使用可计算属性名的地方,都可以使用Symbol,或者Object.defineProperty()方法和Object.defineProperties()方法的调用过程中 Symbol 共享体系有时候我们希望在不同的代码段里面共享同一个Symbol.ES6提供了一个可以随时访问你的Symbol注册表. 如果像创建一个可以共享的Symbol.要使用Symbol.for()方法.它只接受一个参数,也就是即将创建有的Symbol的字符串标识符,这个参数通用也被用作Symbol的描述. 123456789101112let uid = Symbol.for("uid");let object = {};object[uid] = "123";consle.log(object[uid]); //'123'console.log(uid); //"symbol(uid)"let uid2 = Symbol.for("uid");console.log(uid === uid2);// Trueconsle.log(object[uid2]); //'123'console.log(uid2); //"symbol(uid)" Symbol.for()方法首先会在全局Symbol注册表中搜索键为”uid”的Symbol是否存在.如果存在,直接返回已有的Symbol.否则,创建一个新的Symbol,并使用这个键在Symbol全局注册表中注册,随机返回新创建的Symbol. 除此之外还可以使用Symbo了.keyFor()方法在Symbol全局注册表中检索与Symbol有关的键 1234567let uid = Symbol.for("uid");let uid2 = Symbol.for("uid");let uid3 = Symbol("uid");console.log(Symbol.keyFor(uid)); //"uid"console.log(Symbol.keyFor(uid2)); //"uid"console.log(Symbol.keyFor(uid3)); //undefined 尽量使用命名空间来减少命名冲突 Symbol与类型强制转换 切记:不能将Symbol转化为字符串和数字类型,否则如果不小心将其作为对象属性,最终会导致不一样的执行结果 将symbol与一个字符串拼接,会触发隐式类型转换,导致报错 将Symbol与数字类型进行运算,会触发隐式类型转化,导致报错. Symbol式可以作为逻辑运算值的, 它的值等价布尔值true Symbol属性检索Object.keys()和Object.GetOwnPropertyName()方法可以检索对象中所有的属性名,前一个方法返回所有可枚举的属性名,后一个方法则返回所有属性名. 但是这两个方法都是不是支持Symbol属性的. ES6增加了方法Object.getOwnPropertySymbols()方法用来检索Symbol属性,方法的返回值式一个包含所有Symbol自有属性的数组. 12345678910let uid = Symbol.for("uid");let object = { [uid]: "123";};let symbols = object.getOwnPropertySymbols(object);console.log(symbols.length);//1console,log(symbols[0]); //"Symbols(uid)"console.log(object[symbols[0]]);//"123" 所有对象一开始都没有自己独有的属性,但是对象可以从圆形脸肿继承Symbol属性.ES通过一些well-know Symbol与定义了这些属性(暂不展开,如有笔要,以后更新). Symbol的巧用用在单例模式中,防止全局变量被改写单例模式中,为了每次都能返回同一个实例.我们往往会把实例放在顶层对象global上面 12345678910//Mod.jsfunction A(){ this.foo = "Hi";};if(!global._foo){ global._foo = new A();};module.exports = global._foo; 12345678//加载mod.jsconst a = require('./mod.js');console(a.foo);//任意文件都可以随便写global.fooglobal._foo = {foo: "world"};const b = require('./mod.js');console(b.foo); 在这个例子里面变量a任何时候加载的都是A的同一个实例,但是问题在于这里的global._foo是可写的,任何文件都可以对其进行修改,这是一种不安全的行为. 123456789101112// mod.jsconst FOO_KEY = Symbol.for('foo');function A() { this.foo = 'hello';}if (!global[FOO_KEY]) { global[FOO_KEY] = new A();}//这样global[FOO_KEY]不会被无意覆盖,但是还是可以被改写module.exports = global[FOO_KEY]; 1234//这样global[FOO_KEY]不会被无意覆盖,但是还是可以被改写global[Symbol.for('foo')] = { foo: 'world' };const a = require('./mod.js'); 如果希望无法被改写可以是使用symbol(‘foo’)来定义. 这里需要注意的是,当你使用symbol(‘foo’)来定义的时候.如果多次执行这个脚本,每次得到的不一样的Foo_KEY,虽然一般情况下不会多次执行(Node会把脚本执行结果缓存),但是手动清除缓存之后,这种写法并不可靠.]]></content>
      <categories>
        <category>前端学习</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>ES6</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ES-解构:使数据访问更便捷]]></title>
    <url>%2F2019-08-18-Understanding-ECMAScript6-destructuring-assignment.html</url>
    <content type="text"><![CDATA[深入理解ES6-解构皮:使数据访问更便捷 解构赋值由对象字面量和数组字面量语法组成,可以用它来简化操作Javascript对象和数组的过程,从数据结构中抽取其中一部分感兴趣的信息 在对象和数组解构中,都可以对值为undefined的对象属性或数组元素设置默认值,且赋值表达式右值不可以为null或undefined,否则程序会抛出错误. 使用var\const\let来解构声明变量,必须要初始化. 可以使用解构赋值代替其他赋值语句,将对象属性和已有的变量解构成更小的数据 当定义函数参数时,用解构参数options对象可以将你真正感兴趣的数据于其他命名参数列在一起. 过去,现在,将来,一代又一代,直到时间的消失 为什么会使用解构?原因如下: 经常需要从对象和数组中获取局部信息 之前的语法进行1中描述的操作时,必须要深入挖掘整个数据解构才能找到所需的数据 综上,解构作为一种优化功能出现,为了现实的解决上述问题. 对象解构对象解构的语法对象解构的语法形式时一个赋值操作符左边防止一个对象字面量 基本赋值(声明赋值)123456789let node = { value: 20, name: 'Nick' }let {value, name} = node;console.log(value); // 20console.log(name); //'Nick' 使用var\let\const 解构声明变量的时候,必须要提供初始化程序(aka.等号右侧的值).否则就会出现语法错误. 解构赋值基本赋值里面讲诉的时对象解构在变量声明中的应用,我们同样可以在变量赋值的时候使用解构语法. 不过需要注意的是,{}作为代码块语法不能出现赋值等号的左边.我们需要使用() 将整个语句转化为一个表达式,从而完成整个解构赋值的过程. 12345678910111213let node = { value: 20, name: 'Nick' }value = 30;name = 'Jack';//使用解构语法为多个变量赋值({value, name} = node);console.log(value); // 20console.log(name); //'Nick' 解构赋值表达式(也就是=右侧的表达式)如果为null 或者undefined会导致程序抛出错误,也就是说,任何尝试读取null或undefined的属性的行为都会出发运行时错误. 无声明赋值既然由声明赋值就会由无声明,一个变量而可以独立于其声明进行解构赋值. 这是使用小括号原因同上. 12var a, b;({a, b}) = {a: 1, b: 2}); 默认值我们都知道=右边有不存在属性时会报错,为了避免报错,增加了默认值语法. 当指定的属性不存在时, 可以随意顶一个一个默认值,在属性名称后添加一个=和对应的默认值即可. 12345678910let node = { value: 20, name: 'Nick' }let {value, name, type = true} = node;console.log(value); // 20console.log(name); //'Nick'console.log(type); // true 为非同名局部变量赋值前面的例子均为同名变量,其实不同名变量也是支持的. 12345678910let node = { value: 20, name: 'Nick' }let {value: localValue, name: localName, type: localType= true} = node;console.log(localValue); // 20console.log(localName); //'Nick'console.log(localType); // true 嵌套对象解构12345678910111213141516171819let node = { type: "identifier", name: "foo", loc: { start: { line: 1, column: 1 }, end: { line: 1, column: 1 } }};let {loc: { start: localStart }} = node;console.log(localStart.line); // 1cobsole.log(localStart.column); //1 在使嵌套解构功能的时候,内空{}时合法的,然而这语句是什么都不会做. 123> //警示自己不要写这样的代码> let { loc: {}} = node;> 数组解构数组解构使用的是数组字面量 ,且解构操作全部都在数组内完成. 数组解构语法在数组解构语法中,我们通过值在数组中的位置进行选取,且可以将其存储在任意变量中,未显式声明的元素都会被直接忽略.在这个过程中,数组本身不会u发生任何变化. 基本赋值(声明赋值)12345678let colors = ["red", "green", "blue"];let [firstColor, secondColor] = colors;//支持直接忽略元素只为感兴趣的元素提供变量名let [, , thirdColor] = colors;console.log(firstColor); //"red"console.log(sencondColor); //"green"console.log(thirdColor); //"blue" 使用var\let\const 解构声明变量的时候,必须要提供初始化程序(aka.等号右侧的值).否则就会出现语法错误. 解构赋值数组解构也可以使用在解构赋值,和对象解构赋值的不同之处在于,数组解构不需要使用()包裹表达式. 12345678let colors = ["red", "green", "blue"], firstColor = "balck", secondColor = "purple";//这里不再需要(语法[firstColor, secondColor] = colors;console.log(firstColor); //"red"console.log(sencondColor); //"green" 交换变量这里有种特殊用法, 用来交换两个变量的值 123456let a = 1, b = 2;[a, b] = [b, a];console.log(a); // 2console.log(b); // 1 解构赋值表达式(也就是=右侧的表达式)如果为null 或者undefined会导致程序抛出错误,也就是说,任何尝试读取null或undefined的属性的行为都会出发运行时错误. 默认值12345let colors = ["red"];let [firstColor, secondColor = "blue"] = colors;console.log(firstColor); //"red"console.log(sencondColor); //"blue" 嵌套数组解构123456let colos = ["red", ["green", "lightgreen"], "blue"];let [firstColor, [sendColor]] = colors;console.log(firstColor); //"red"console.log(secondColor); //"green" 不定参数解构数组中可以使用…语法表示不定参数.不定参数也可以用于数组解构之中 12345678let colors = ["red", "green", "blue"];let [firstColor, ...restColors] = colors;console.log(firstColor);//"red"console.log(restColors.length); //2console.log(restColors[0]); //"green"console.log(restColors[1]);//"blue" 需要注意的是,补丁参数必须啊hi是被解构数组的最后一个条目.后面还出现逗号会被程序抛出异常. 复制数组1234let colors = ["red", "green", "blue"];let [...clonedColors] = colors;console.log(clonedColors); //"["red", "green", "blue"]" 混合解构现实中的数据往往是对象于数组的混合机构,因此解构语法也支持这种混合解构. 12345678910111213141516171819202122232425let node = { type: "Identifier", name: "foo", loc: { start: { line: 1, column: 1 }, end:{ line: 1, column; 1 } } range: [0, 3];}let { loc : {start}, range: [startIndex]} = node;console.log(start.line); //1console.log(start.column); //1console.log(startIndex); //0 解构参数 解构可以用在函数参数的传递过程中,这种使用方式更特别.将参数定义为解构参数,则可以更清晰的了解函数预期传入的参数.解构参数需要哦使用对象或数组解构模式代替命名参数. 123456789//第三个参数使用解构语法function(name. value, {secure, path, domain, expires}){ }setCookie("type", "js", { secure: true, expires: 6000}); 必须传值的解构参数解构参数中有个一个奇怪的地方, 在默认情况下,如果调用参数是不提供被解构的参数会导致程序抛出错误. 123456789function(name. value, {secure, path, domain, expires}){ }setCookie("type", "js"); // 错误//所以默认情况下,解构参数是必传参数,如果不是,则需要为他设置默认值function(name. value, {secure, path, domain, expires} = {}){ } 解构参数的默认值我们可以为解构参数设定默认值 12345678function setCookie(name, value, { secure = false, path = "/", domain = "example.com", expires = new Data(Data.now() + 360000000) }){} 但是这种写法先得很复杂,除此之外,如果解构参数是可选的,那么还要为他添加一个空对象作为参数. 因此对于对象类型的解构参数,建议直接为其赋予相同解构的默认参数 123456789101112131415161718192021222324252627282930function setCookie(name, value, { secure = false, path = "/", domain = "example.com", expires = new Data(Data.now() + 360000000) } = { secure = false, path = "/", domain = "example.com", expires = new Data(Data.now() + 360000000) }){}//使用独立对象优化下上面的写法const setCookiedefaults ={ secure = false, path = "/", domain = "example.com", expires = new Data(Data.now() + 360000000) }function setCookie(name, value, { secure = false, path = "/", domain = "example.com", expires = new Data(Data.now() + 360000000) } = setCookieDefaults){} 参考资料 MSDN-解构赋值]]></content>
      <categories>
        <category>前端学习</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>ES6</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ES6-扩展对象的功能性]]></title>
    <url>%2F2019-08-10-Understanding-ECMAScript6-Extend-the-functionality-of-an-object.html</url>
    <content type="text"><![CDATA[ES6为对象新增很多很好用的属性和方法 增加了super引用 清晰定义了自由属性的枚举顺序 过去,现在,将来,一代又一代,直到时间的消失 对象类别 普通对象: 具有JavaScript对象多有的默认内部行为. 特异对象: 具有某些与默认行为不符的内部行为. 标准对象: ECMAScript 6 规范中定义的对象.eg, Array, Date等.标准对象既可以是普通对象,也可以是特异对象. 内建对象:脚本开始执行时存在于Javascript执行环境中的对象,所有标准对象都是内建对象 对象字面量语法扩展属性初始值的简写123456789101112131415//ES5写法function createPerson(name, age){ return { name: name, age: age };}//ES6写法-支持了简写function createPerson(name, age){ return{ name, age };} 对象方法的简写语法123456789101112131415//ES5var person = { name: "person", sayName: function(){ console.log(this.name) }};//ES6var person = { name: "person", sayName(){ console.log(this.name) }}; 两种写法的差别在于,简写的方法可以使用super. 可计算属性名(Computed Property Name)在ES6中支持了在对象字面量中使用可计算的属性名称,其语法于引用对象实例的可计算属性名称相同,也是使用方括号. 123456789101112let lastName = "last name";var suffix = "name";let person = { "first name": "Nick", [LastName]: "Zakas", ["Second" + suffix]: "Nicky",};console.log(person["first name"]); //"Nick"console.log(person["last name"]); //Zakas"console.log(person["Secondname"]); //"Nicky" 新增方法ESCMAScript其中一个设计目标是:不再闯进新的全局函数,也不在Object.prototype上创建新的方法.为了简化某些操作,在Object上新增了一些方法. Object.is()方法 用于比较两个值 和===最大的不同在于, === 认为(+0=== -0, NaN === NaN)的结果是false, 而is()可以弥补全等运算符的不准确运算. is()判定的准则: 如果两个参数的类型相同且具有相同的值,则返回true. Object.assign()方法 是浅拷贝,拷贝的是指针 这个方法接受一个接受对象和任意数量的源对象,最终返回接受对象.同名情况,后覆盖前 Object.assign()方法不能将提供者的访问器属性复制到接收器对象中.访问器属性最终会因为先调用方法变成一个值存储在接收对象中. 重复的对象字面量属性 ES6中,无论是严格模式还是非严格模式,都不再检查重复属性,对于重复属性,取最后一个值. 自有属性枚举顺序原先的对象属性枚举顺序是有引擎厂商定义的.ES6中严格规定了对象的自由属性被枚举时的返回顺序,这会影响到Object.getOwnPropertyNames()方法及Reflect.ownKeys返回属性的方式,Object.assign()方法处理属性的顺序也将随之改变. 自有属性的枚举顺序为 所有数字键按升序排序 所有字符串键按照他们被加入对象的顺序排序 所有symbol键按照他们被加入对象的顺序排序 虽然如此但是,for-in, object.keys(), JSON.stringify()方法的顺序未明. 增强对象原型改变对象的原型ES6中增加了Object.setPrototypeOf()方法来改变任意指定对象的原型,它接受两个参数:被改变原型的对象及替代第一个参数原型的对象. 1234567891011121314151617181920let person = { getGreeting(){ return "Hello"; }};let dog = { getGreeting(){ retrun "woof"; }};let friend = object.create(person);console.log(friend.getGreeting()); //"Hello";console.log(friend.getPrototype(friend) === person); //true//原型设置为dogObject.setPrototyeOf(friend. dog);console.log(friend.getGreeting()); //"woof";console.log(friend.getPrototype(friend) === dog); //true 不过这不是操作[[prototype]]的唯一方法. 简化原型访问的Super引用ES6中引入的Super引用,使用它可以简单快捷的访问对象的原型.尤其再重写对象实例的方法中调用与它同名的原型方法. 123456let friend = { getGreeting(){ // return object.getPrototypeOf(this).getGreeting.call(this) return super.getGreeting() + ". hi!"; }}; 需要注意的时,再方法声明中调用super,必须是再使用简写方法的对象中声明,其他写法会导致报错. Super引用不是动态变化的,它总是能指向正确的对象.再多重继承的代码中,这一特性显得十分好用. 正式的方法定义在ES6中,方法正式被定义为一个函数,它将会有一个[[HomeObject]]属性来容纳这个方法丛书的对象. 1234567891011let person = { //是方法 getGreeting(){ return "Hello"; }};//不是方法function shareGreeting(){ return "Hi!"; }; Super的所有引用都是通过[[HomeObject]]属性来确定后续的运行过程.第一步实在[[HomeObject]]属性上调用Object.getPrototypeOf()方法来检索原型的引用.然后搜索原型找到同名的函数,最后设置this绑定并且调用相同的方法.]]></content>
      <categories>
        <category>前端学习</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>ES6</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ES6-函数(2)]]></title>
    <url>%2F2019-08-04-Understanding-ECMAScript6-Function-2.html</url>
    <content type="text"><![CDATA[为了修正很多函数问题,避免基本功能重复编码,ES6大力度的更新的函数特性. 块级函数 箭头函数 尾调用的优化 过去,现在,将来,一代又一代,直到时间的消失 # 块级函数 历史溯源在 ES3和早期的版本中,在代码块中声明一个块级函数严格来说一个错误,但是所有的浏览器仍然支持了这个特性,且每个浏览器对这个特性的支持成都都不同.(推荐的方式是使用函数表达式[不会发生声明提前]). 为了抑制这种相互不兼容的行为,ES5在严格模式中引入了错误提示,挡在代码块内部声明函数是会抛出错误: 123456789"use strict"if(true){ //在ES5中会抛出语法错误 //在ES6中不会,ES6会将其视为一个块级声明,从而可以在定义该函数的代码块内访问和调用它 function doSomething(){ //空函数 }} 在ES6中的调用如下 1234567891011"use strict"if(true){ console.log(typeof doSomething); //"function" //在定义函数的代码块内,块级函数会被提升至顶部,但是if一旦执行结束,dosomething函数将不存在 function doSomething(){ //空函数 } doSomething();}console.log(typeof doSomething); //"undefined" 块级函数的使用场景块级函数与let函数表达式相似,一旦执行过成流出代码块,函数定义立即被移除.二者的区别在于 在该代码块中,块级函数声明会被提升至该块的顶部 使用let定义的函数表达式则不会发生声明提升的情况 所以按需使用这两种写法吧 非严格模式下的块级函数在ES6中, 严格模式与非严格模式下的块级函数略有不同. 在严格模式下,块级函数会被提升至代码块顶部 在非严格模式下,会被提升指外围函数或全局作用于的顶部 箭头函数为什么要有箭头函数?this绑定是javascript程序产生错误的一个常见来源,在函数内很容易对this的值失去控制.箭头函数为了限制this值,减少错误和模糊不清的地方而生. 箭头函数与传统函数的差异ES6中新增了箭头函数这个特性-使用=>定义函数的新语法.但是它和传统的JavaScript函数有些不同.主要表现在: 没有this\super\arguments\new.target绑定. 箭头函数中的这些值由外围最近一层的非箭头函数决定 不能通过new关键字调用. 箭头函数没有[[Construct]]方法,所以不能被用作构造函数,如果通过new关键字调用箭头函数,程序会抛出错误. 没有原型. 由于不能通过new关键字嗲用箭头函数,因而没有构造原型的需求,因此箭头函数不存在prototype这个属性 不可以改变this的绑定. 函数内部的this值不可被改变,在函数的声明周期内始终保持一致. 不支持arguments对象. 箭头函数没有arguments绑定,所以必须通过命名参数和不定参数的形式的去访问函数的参数 不支持重复的命名参数.无论在严格还是非严格模式下,箭头函数都不支持重复的命名参数. 箭头函数同样有name属性,这点与其余函数规则一致. 箭头函数的语法箭头函数的语法有多种形式,主要归纳为函数参数\箭头\函数体三种表达 单一参数,并且只是简单的返回了参数值 1234567let reflect = value => value;//效果相当于let reflect = function(value){ return value;}; 当需要传入两个或两个以上参数的时候 1234567let sum = (num1, num2) => num1 + num2;//效果相当于let sum = function(num1, num2){ return num1 + num2;}; 没有参数的时候 1let getName = () => "Nick"; 函数体包含多个语句,这时候需要显示的返回值 123let sum = (num1, num2) => { return num1 + num2;}; 空函数 1let nothing = () => {}; 箭头函数需要返回一个字面量的时候,把字面量包裹在一个()里面 123456789let getItem = id => ({id: id, name: "temp"});//效果相当于let getItem = function(id){ return { id: id, name: "temp" }}; 创建立即执行函数表达式JavaScript函数中一个流行的使用方式是创建立即执行函数表达式(IIFE),你可以定义一个匿名函数并立即调用,自始自终不保存对该函数的引用.当你想要创建一个与其他程序隔离的作用于时,这种模式非常方便. 12345678let person = functiton(name){ return{ getName: function(){ return name; } };}("nick");console.log(person.getName()); //"nick"; 只要把箭头函数包裹在(),就是使用箭头函数完成相同功能. 需要注意的是,()只包裹箭头函数定义的部分,没有包含(“nick”),这一点与正常函数有所不同,由正常函数定义的立即执行函数表达式既可以用()包裹函数体,也可以额外包裹函数的调用部分. 12345678let person = ((name) => { return{ getName: function(){ return name; } };})("nick");console.log(person.getName()); //"nick"; 箭头函数没有this绑定如果箭头函数被非箭头函数包含,则this绑定的是最近一层非箭头函数的this,否则this的值会被设置成为全局对象.且this的值不能被更改. 123456789let PageHandler = { id: "123456", init: function(){ document.addEventListener("click", event=> this.doSomething(event,type), false); }, dosomething: function(type){ console.log("Handling " + type + "for " + this.id); }}; 箭头函数与数组箭头函数的语法非常简单,非常适合用来处理数组. 1var result = values.sort((a, b) => { a-b}); sort(),map(),reduce()等可以接受回调凹函数的数组方法,都可以通过箭头函数语法简化编码过程. 箭头函数没有arguments绑定箭头函数没有自己的arguments对象,且未来无论函数在哪个上下文中执行,箭头函数使用可以访问外围的arguments对象. 箭头函数的辨识方法使用typeof和instanceof 操作符调用箭头函数与调用其他函数并没有差别.不过我们还是可以同一些技巧将其辨识 出来. 箭头函数使用call(),apply(),bind()这些方法,函数this值不受影响. 什么地方适合用箭头函数包括回到函数在内所有使用匿名表达式的地方都合适用箭头函数来改写. 尾调用什么是尾调用?函数作为另外一个函数的最后一条语句被调用. 尾调用会有什么问题?在ES5中,尾调用和其他函数调用的实现类似: 创建一个新的stack frame,将其推入调用栈来表示函数调用.当出现循环调用的时候,每一个未用完的stack frame 都会被保存在内存中,当调用栈编得过大的时候会带来程序问题. ES6中的尾调用优化ES6中缩减了严格模式下(非严格模式不受影响)尾调用栈的大小,如果满足以下条件,尾调用不再创造新的stack frame,而是清除并重用当前stack frame 尾调用不访问当前stack frame的变量(也就是说函数不是一个闭包) 在函数内部,尾调用是最后一条语句 尾调用的结果作为函数值返回. 如何利用尾调用实际上,尾调用的优化发生在引擎背后,除非尝试优化一个函数,否则无须思考此类问题.递归函数是最重要的应用场景,优化效果显著. 123456789101112131415161718// 无法优化function factorial(n){ if (n]]></content>
      <categories>
        <category>前端学习</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>ES6</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记]]></title>
    <url>%2F2019-07-28-Just_Play_Accounting.html</url>
    <content type="text"><![CDATA[读书笔记 基本的会计概念 自己记录备用 前言本文仅是个人读书笔记,欢迎批评指正.]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解ES6-函数(1)]]></title>
    <url>%2F2019-07-14-Understanding-ECMAScript6-Function_1.html</url>
    <content type="text"><![CDATA[为了修正很多函数问题,避免基本功能重复编码,ES6大力度的更新的函数特性. 函数形参的默认值语法支持 支持无命名参数的处理 增强的Function构造函数 展开运算符 Name 属性 明确函数的多重用途 过去,现在,将来,一代又一代,直到时间的消失 函数形参的默认值众所周知,Js中的函数与其他语言函数最大的不同在于,JS中的函数不介意传递进来参数的类型与个数.实际上,在函数体内通过arguments对象来访问整个参数数组.arguments对象是一个类似数组(但不是的Array的实例),它支持[]语法. ES5模拟默认参数与ES6默认参数在ECMAScript5中模拟默认参数1234function makeRequest(url, timeout, callback){ timeout = timeout || 2000; callback = callback || function() {};} 在这个例子中,timeout与callback为可选参数,未传递的话自动赋予初始值.对于函数的命名参数来说,不显示传值,则其值默认未undefined.在这个例子中,大部分情况是正确的,但是一旦遇到timeoout显示传递0进入时,仍会被条件表达式判定为假值,并强制更改其值为2000. 于是我们不得不增加判断参数类型的写法,以保证逻辑的正确性 1234function makeRequest(url, timeout, callback){ timeout = (typeof timeout !== 'undefined')? timeout : 2000; callback = (typeof callback !== 'undefined')? callback : function() {};} 在ECMAScript6中默认参数在ES6中针对函数形参的默认值给出了简化写法.如果没为参数传入值则为其提供一个初始值(语法与.net的写法类似).不再需要自行增加任何检验值是否缺失的代码.与.net写法不同的时,在已指定默认值的参数后可以继续声明无默认值参数. 123function makeRequest(url, timeout = 2000, callback){} 默认参数值对arguments对象的影响12345678910function mixArgs(first, second){ console.log(first === arguments[0]); console.log(second === arguments[1]); first = 'c'; second = 'd'; console.log(first === arguments[0]); console.log(second === arguments[1]);}mixArgs('a','b'); 在ES5中严格模式与非严格模式下的输出迥异. 1234567891011//非严格模式下,命名参数的变化会同步到arguments对象中truetruetruetrue//严格模式下,命名参数的变化不会同步到arguments对象中truetruefalsefalse 在ES6中,如果一个函数使用了默认参数值,则无论是否显式定义了严格模式,arguments对象的行为都将与ECMAScript5 严格模式下的执行保持一致. 默认参数表达式关于默认参数值,最有趣的特性可能是非原始值传参. 123456789101112let value = 5;function getValue() { return value++;}function add(first, second = getValue()){ return first + second;}console.log(add(1, 1)); //2console.log(add(1)); //6console.log(add(1)); //7 初次解析函数声明时不会调用getValue.只有当真实需要赋予默认参数值(2参数未传递时),才会调用此函数. 注意,当使用函数调用结果作为默认参数值时,如果忘记写().则最终传入的时是函数的引用,而不是函数调用的结果. 正是因为默认参数实在函数调用时求值,所以可以使用先定义的参数作为后定义参数的默认值.此外,只允许引用前面参数的值,即先定义的参数不能访问后定义的参数. 1234567891011function add(first, second = first){ return first + second;}console(add(1)); //2//不被允许的写法function add(first = second, second){ return first + second;}console.log(undefined, 1); //抛出错误 默认参数的临时死区与let声明类似,定义参数时会为每个参数创建一个新的标识符绑定,该绑定在初始化之前不可被引用,如果试图访问则会抛出错误.当调用函数时,会通过传入的值或参数的默认值初始化该参数. 函数参数有自己的作用于与临时死去,其与函数体的作用域时各自福利的,也就是说参数的默认值不可以访问函数体内声明的变量. 处理无命名参数对于函数的参数还可以使用无命名(通过arguments[index])访问的方式. 不定参数 在函数的命名参数钱添加…表明这是一个补丁参数,该参数为一个数组,包含着自他之后传入的所有参数,通过这个数组名即可逐一访问里面的参数. 123456789function pick(object, ...keys){ let result = Object.create(null); for (let i = 0, len = keys.length; i < len; i++){ return[keys[i]] = object[keys[i]]; } return result;} 不定参数keys包含的是object之后传入的所有参数 函数的length属性统计的是函数命名参数的数量,不定参数的加入不会影响length属性的值.length(pick) = 1 不定参数的使用限制 每个函数最多只能声明一个不定参数,并且一定要放在所有参数的末尾. 不定参数不能用于对象字面量setter之中.对象字面量setter的参数有且只能有一个. 不定参数对arguments对象的影响 不定参数的设计初衷是代替JavaScript中的arguments对象.因为种种原因,导致的现状是不定参数与arguments参数同时存在. 如果声明函数时定义了不定参数,则在函数被调用时,arguments对象包含了所有传入函数的参数. 其实无论是否使用了不定参数,arguments对象总是包含所有传入函数的参数. 增强的Function构造函数 Function 构造函数通常被用来动态创建构造函数.这种构造函数接受字符串形式的参数,分别为函数的参数及函数体(以字符串的形式传递). 12var add = new Function("first", "second", "return first + second");console.log(add(1, 1)); //2 ES6 中增强了Function构造函数的功能,支持在擦黄健函数时定义默认参数与不定参数 12345var add = new Function("first", "second = first", "return first + second");console.log(add(1)); // 2var pickFirst = new Function("...args", "return args[0]");cosole.log(pickFirst(1, 2)); //1 展开运算符不定参数可以让你指定多个各自独立的参数,并通过整合后的数组来访问.而展开运算符可以让你指定一个数组,将他们打散后作为各自独立的参数传入函数.Javascript内建的Math.max()方法可以接受任意数量的参数并返回值最大的那一个.但是面对数组,Math.max()无法接受其作为参数.想要获取数组中的最大值.只能遍历或者使用apply方法. 123456789//在ES5中从数组中挑选最大的哪个值let values = [25, 50, 75, 100]console.log(Macth.max.apply(Math, values)); //100//在ES6中的展开运算符可以简化以上写法.方式为在数组前面加入不定参数...符号let values = [25, 75, 50, 125]console.log(Math.max(...values)); //100//这种写法等价于console.log(Math.max(25, 75, 50, 125)); 在使用数组给函数传递参数的过程中,大部分使用apply()方法的场景都可以使用展开运算符做替代方案. name属性如何选择合适的名称 ES6程序中的所有的函数的name属性都有一个合适的值.在接下来的示例中展示了一个函数和一个函数表达式,并打印了各自的name属性: 1234567891011 function doSomething(){ //空函数 }//匿名函数表达式的name对应着被赋值为该匿名函数的变量的名称 var doAnotherThing = function() { // 空函数 } console.log(doSomething.name); // "doSomething" console.log(doAnotherThing.name); //"doAnotherThing" name属性的特殊情况1234567891011121314151617181920var doSomething = function doSomethingElse(){ //empty function}var person = { get firstName (){ return "Nick" }, sayName : function(){ console.log(this.name); }}//函数表达式名称>函数本身被赋值的变量名console.log(doSomething.name); //"doSomethingElse"//取值为对象字面量console.log(person.sayName.name); //"sayName"//getter setter对象有各自的前缀console.log(person.firstName.name); //"get firstName" 12345678var doSomething = function(){ //empty function};//通过bind()函数创建的函数,其名称将带有"bound"前缀console.log(doSomething.bind().name); //"bound doSomething"//通过Function构造函数创建的函数,其名称将是"anonymous"//console.log(new Function().name); //"anonymous" 注意: 函数name属性的值不一定引用同名变量,他只是协助调试用的额外信息,所以不能使用name属性的值来获取对于函数的引用. 明确函数的多重用途ES5及其早期版本中的函数具有多重功能,可以结合new使用,函数内的this值将只想一个新对象,函数最终会返回这个新对象. 12345678function Person(name){ this.name = name;}var person = new Person("Nick");var NotAPerson = person("Nick");console.log(person); //"[Object object]"console.log(NotAPerson); //"undefined",非严格模式下,还会在全局对象中设置一个name属性 JavaScript 函数有两个不同的内部方法:[[call]]和[[Construct]].当使用new关键字调用函数时,执行的时[[Construct]]函数,它负责创建一个通常被称作实例的新对象,然后再执行函数体,将this绑定到实例上;如果不使用new关键字,则执行[[call]]函数, 从而直接支持性代码中的函数体.具有[[Construc]]方法的函数被统称为构造函数. ECMAScript5中判断函数被调用的方法在ES5中,如果想确定一个函数是否通过new关键字被调用(或者说,判断该函数是否做欸构造函数被调用),最流行的方式就是用instanceof,举个例子: 12345678910function Person(name){ if (this instanceof Person){ this.name = name; } else { throw new Error("必须通过new关键字来调用person") }}var person = new Person("Nick");var NotAPerson = Person("Nick"); //抛出错误 在这段代码中,首先检查this的值,看他是否为构造函数的实例,如果时则正常执行,否则抛出错误.由于[[Construct]]方法会创建一个Person的新势力,并将this 绑定到新势力上,通常来讲这样做时正确的,但是这个方法也不完全可靠,因为有一种不宜俩new关键字的方法也可以将this绑定到person实例上. 12345678910function Person(name){ if (this instanceof Perso){ this.name = name; } else { throw new Error("必须通过new关键字来调用person") }}var person = new Person("Nick");var notAPerson = Person.call(person "Michael"); //有效! 调用Person.call()时将变量person传入作为第一个参数,相当于在Person函数里将this设为person实例.对于函数本身,无法却分是通过Person.call(或者时Person.apply())还是new关键字调用得到的Person实例. 元属性(metaproperty) new.target为了解决判断函数是否通过new关键字调用的问题,ECMAScript6引入了new.target这个元属性.元属性是指非对象的属性,其可以提供非对象目标的补充信息(例如new). 当调用函数的[[Construct]]方法时,new.target被赋值为new操作符的目标,通常是新创建对象实例,也就是函数体内this的构造函数; 如果调用[[call]]方法,则new.target的值为undefined. 有了这个元属性,可以通过检查new.target石佛普被定义过来安全地检测一个函数是否通过new关键字调用的,就像这样 12345678910function Person(name){ if (typeof new.target !== "undefined"){ console.log( typeof new.target); //"function" this.name = name; } else { throw new Error("必须通过new关键字来调用person") }}var person = new Person("Nick");var notAPerson = Person.call(person, "Michael"); // 抛出错误 举一反三,可以利用元属性.检查是否被某个特性的构造函数所调用 12345678910111213function Person(name){ if (new.target == Person){ this.name = name; } else { throw new Error("必须通过new关键字来调用person") }}function AnotherPerson(name){ Person.call(this, name);}var person = new Person("Nick");var AnotherPerson = new AnotherPerson("Michael"); // 抛出错误 在函数外使用new.target时一个语法错误]]></content>
      <categories>
        <category>前端学习</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>ES6</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ES6-字符串与正则表达式]]></title>
    <url>%2F2019-06-29-Understanding_ECMAScript6_String-and-Regular-expression.html</url>
    <content type="text"><![CDATA[深入理解ES6-字符串与正则表达式 ES6完全支持了Unicode从而让Javascipt能够合理地处理UTF-16字符. ES6为字符串和正则表达时添加了新的方法 ES6新增了一个重要特性-模板字面量,为JavaScript带来多行字符串的内建支持,并且它支持字符串占位符写法. 过去,现在,将来,一代又一代,直到时间的消失 字符的编码字符集与字符编码 计算机中存储的信息都是使用二进制表示的.将我们熟悉的文字符号以既有的规则(如二进制)表示,这就称之为编码.与其对应的过程称之为解码. 字符集(Charset): 将所有字符汇总起来的集合. 字符编码(Character encoding):是一套规则.使用该规则可以实现自然语言中的一个集合,与其他规则集合(如电脉冲/数字)建立映射关系. 码位(Code Point):全球唯一的标识符,是从0开始的字符 utf-8/utf-16/utf-32早期的计算集使用Ascii码对英文字符进行编码.但是随着计算机的普及发展,使用其他语言的国家为了对自己语言字符进行表达,纷纷推出了自己编码规则(即字符编码).比较典型的有表示简体中的gb2312,表示繁体中文的BIG5. 这种为了适合当地的语言和字符,设计新字符编码规则的做法,在本地使用没有任何问题,但是相 io互访问就会出现乱码现象. 为了解决乱码问题,一个伟大的创想-Unicode诞生了.Unicode是一个字符集,它是基于通用字符集的标准发展而来,所致力的目标位位全世界每一个字符提供全球唯一的标识符,目前已经成为计算机科学领域里的一项业界标准.XML/Java编程语言/现代的操作系统都采用了Unicode字符集.我们常说的utf-8/utf-16/utf-32是针对Unicode字符集的三种字符编码方案. utf-32使用4个字节来表示每一个字符,优点是编码规律(第N个字符一定是从4的N次方个字节开始).但是就空间而言,完全没有效率. Utf-16使用两个字节表示0~65535个字符,65535范围被成为基本多文种平面[BMP, Basic Multilingual Plane])的字符,而对于超出65525范围(辅助平面(supplementary plane))则需要一些特殊的技巧来实现.为此uft-16引入了代理对(surrogate pair),其规定两个16位编码单元表示一个码位. uft-8使用一至四个字节位每个字符编码.是一种针对Unicode的可变长度字符编码(定长码),也是一种前缀码.他可以用来表示Unicode标准中的任何字符,并且其编码的第一个字节仍与ASCII兼容,这使得它逐渐成电子邮件/网页或传输文字的应用中最优先采用的编码.IETF要求所有的互联网协议都必须支持utf-8编码. 这也就是说在utf-16中有两种字符 使用一个编码单元16位表示的BMP字符 使用两个编码单元32位表示的辅助屏幕面字符 值得一提的是,除了多种编码方式,不同操作系统之间的大小字节序也影响着对字节的编码与解码.为了解决这个问题，多字节的Unicode编码方式定义了一个”字节顺序标记(Byte Order Mark)”，它是一个特殊的非打印字符，你可以把它包含在文档的开头来指示你所使用的字节顺序。对于UTF-16，字节顺序标记是U+FEFF。如果收到一个以字节FF FE开头的UTF-16编码的文档，你就能确定它的字节顺序是单向的(one way)的了；如果它以FE FF开头，则可以确定字节顺序反向了。 ES6对utf-16的支持在ES5中,所有的字符串操作都是基于16位编码单元.这时候如果使用对使用了两个编码单元32位表示的字符使用对应的方法,则会导致得到的结果与预期不符合. 12345678let text = "𠮷";console.log(text.length); //2 长度实际位1,但是length位2console.log(/^.$/.test(text)); //false 正则表达式是用来判定单一字符的.因此失效.console.log(text.charAt(0)); //"" 前16位不包含可打印字符console.log(text.charAt(1)); //"" 后16位不包含可答应字符console.log(text.charCodeAt(0)); //55362 charCodeAt()会返回每16个编码单元对应的数值.console.log(text.charCodeAt(1)); //57271 正是因为以上的种种的问题,ES6中强制使用utf-16编码来解决上诉问题,并按照这种字符编码来标准准话字符串操作,在Javascript中增加专门针对代理对的功能. codePointAt()方法ES6新增完全支持UTF-16的codePointAt()方法,这个方法接受的编码单元的位置,而非字符位置作为参数,返回与字符串中给定位置对应的码位,即一个整数值. 123456789let text = "𠮷a";console.log(text.charCodeAt(0)); //55362 console.log(text.charCodeAt(1)); //57271console.log(text.charCodeAt(2)); //97console.log(text.codePointAt(0)); //134071console.log(text.codePointAt(1)); //57271console.log(text.codePointAt(2)); //97 最佳实践:要检测一个字符占用的编码单元数量,最简单的方法是调用字的codePointAt()方法. 12345function is32Bit(c){ return c.codePointAt(0) > oxFFFF;}console.log(is32Bit("𠮷")); //trueconsole.log(is32Bit("a")); //false String.formCodePoint()方法ES6中提供的String.formCodePoint()方法是codePointAt()的反向方法,用于根据制定码位生成一个字符. 1console.log(String.formCodePoint(134071)); normalize()方法Unicode的另一个有趣之处在于,如果我们要对不同字符进行排序或比较操作,会存在一种可能,他们是等效的.所谓的规范等效存在两种情况: 无论从哪个角度来看,两个序列的码位都是没有区别的 两个互相兼容的码位序列看起来不同,但是在特定的条件下可以被互相交换使用.其本质是通过特定的方法把等效标准化. ES6为字符串添加了一个normalize()方法,它可以提供Unicode的标准化形式.这个方法接受一个可选的字符串参数,指明应用以下的Unicode标准化形式. 以标准等价方式分解,然后以标准等价方式重组(‘NFC’), 以标准等价方式分解(‘NFD’) 以兼容等价方式分解(‘NFKC’) 以兼容等价方式分解,然后以标准等价方式重装(‘NFKD’) 最佳实践: 在对比字符串之前一定要先把他们标准化为同一形式.在国际化的开发中应用广泛. 12345678910111213141516171819202122232425262728//对数组中的每一个字符串进行比较let normalize = values.map(function(text){ return text.normalize();});normalize.sort(function(first, second){ if (first < second){ return -1; } else if (first = second){ return 0; } else { return 1; }});//比较原始数组values.sort(function(first, second){ let firstNormalized = first.normalize(), secondNormalized = second.normalize(); if(firstNormalized < secondNormalized){ return -1; } else if (firstNormalized = secondNormalized){ return 0; } else { return 1; }}); 正则表达式u修饰符正则表达式是应用非常广泛,有很多好用的在线正则表达式网站.正则表达式默认将字符串的每一个字符按照16位编码单元处理.当遇到32位编码单元时就就出现错误.为了解决这个问题,ES6中引入了正则表达式u修饰符. 当一个正则表达式添加了u修饰符,他就会从编码操作模式切换为字符模式,如此一来正则表达式就不会视代理对为两个字符,从而完全按照预期正常运行. 1234let text = "𠮷";console.log(text.length); //2console.log(/^.$/.test(text)); //false /^.$/表示匹配所有但字符字符串,没有用U时会匹配编码单元.使用u时会切换到匹配字符模式console.log(/^.$/u.test(text)); //false 虽然ES6中并没有支持字符串码位数量的检测,但是有了u修饰符之后,可以用正则表达式来解决这个问题. 123456function codePointLength(text){ let result = text.match(/[\s\S]/gu); //[\s\S]保证名匹配到新行 return result ? result.length : 0;}console.log(codePointLength('𠮷bc')); // 3 最佳实践:因为u修饰符时语法层面的变更,尝试在不兼容ES6的JavaScript引擎中使用它会导致语法错误.如果要检测当前引擎是否支持u修饰符,最安全的方式时通过以下这个函数: 1234567891011//代码工作在老式的JavaScript引擎中,那么在使用u修饰符时,切记//要使用RegExp构造函数,这样可以避免发生语法错误,并且可以有选择的//检测和使用u修饰符function hasRegExpU(){ try { var pattern = new RegExp(".", "u"); return true; } catch (ex){ retun false; }} 其他字符串变更字符串中的子串识别之前的版本中我们一直使用indexOf()方法在一段字符串中检测另一端子字符串,他们一直希望能通过更简单的方法来识别字串. ES6 中增加3个类似的方法可以达到相同的效果. includes()方法,如果在字符串中检测到指定文本则返回true,否则返回false startsWith()方法,如果在字符串的起始部分检测到指定文本则返回true,否则返回false endsWith()方法,如果在字符串的结束部分检测到指定文本则返回true,否则返回false 以上三种方法都支持两个参数(searchText,[startIndex]). 实践注意: 如果需要获得子串在字符串中的实际位置还是得用indexOf()或lastIndexOf() indexOf()或lastIndexOf()的参数中可以传入正则表达式(他们会把正则表达转化为一个字符串并搜索它).但是在以上三个方法中,第一个参数传入正则表达式则会出发一个错误. repeat()方法ES6为字符串增加了repeat()方法,其接受一个number类型的参数,表示该字符串重复的次数,返回值时当前字符串重复一定次数后的新字符串. 1console.log("x".repeat(3)); //xxx 最佳实践,可以用这个方法来控制缩进 12345let indent = " ".repeat(4), indentLevel =0;//当需要增加缩进的时候let newIndent = indent.repeat(++indentLevel); 其他正则表达式语法变更正则表达式y修饰符 y修饰符曾在Firefox中被实现过,现在经ES6标准化后正式成为正则表达式的一个专有扩展.它会影响正则表达式搜索过程中的sticky属性.当在字符串中开始字符匹配时,他会通知搜索从正则表达式的lastIndex属性开始进行,如果在指定位置没能成功匹配,则停止继续匹配. lastIndex属性指明每次搜索开始的位置 g修饰符从这个位置开始向后搜索直到匹配位置 y修饰符同样遵守lastIndex属性,但是要求必须在lastIndex指定的位置发现匹配.实际上y修饰符隐含了头部匹配的标志^.y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。 当执行操作的时候,y修饰符和g修饰符都会把上一次匹配后面一个字符的索引把偶你在lastIndex中;如果该操作匹配的结果为空,则lastIndex会被重置为0. 1234567891011121314151617181920212223 let text ="hello1 hello2 hello3", pattern = /hello\d\s?/, result = pattern.exec(text), globalPattern = /hello\d\s?/g, globalResult = globalPattern.exex(text), stickyPattern = /hello\d\s?/y, stickyResult = stickyPattern.exec(text);console.log(result[0]); //"Hello1"console.log(globalResult[0]); //"Hello1"console.log(stickyResult[0]); //"Hello1"pattern.lastIndex = 1;globalPattern.lastIndex = 1;stickyPattern.lastIndex = 1;result = pattern.exec(text);globalResult = globalPattern.exex(text);stickyResult = stickyPattern.exec(text);console.log(result[0]); //"Hello1"console.log(globalResult[0]); //"Hello2"console.log(stickyResult[0]); // 抛出错误 使用y修饰符的时候,还需要记住以下几点: sticky 属性时候只读属性,其值由该修饰符的存在性所决定. 只有调用exec()和test()这些正则表达式对象的方法时才会涉及lastIndex属性;调用字符串的方法,例如match(),则不会触发沾滞行为. 1234//单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。let text = 'a1a2a3';text.match(/a\d/y) // ["a1"]text.match(/a\d/gy) // ["a1", "a2", "a3"] 对于沾滞正则表达式而言,如果使用^字符来匹配字符串开端,指挥从字符串的起始位置或多行模式的首行进行匹配. 若要检测y修饰符是否存在,与检测其他正则表达式修饰符类似,可以通过属性名来检测.sticky属性表示是否设置了y修饰符 1234567891011121314//检查sticky属性的存在性let pattern = /hello\d/y;console.log(pattern.sticky); //如果Javasc引擎支持沾滞修饰符,则sticky的属性为true.//检查JavaScript引擎对y修饰符的支持,不支持则会报错.在老浏览器里面运行一定要记得增加判断function hasRegExpY{ try{ var pattern = new RegExp(",", "y"); return true; } catch (ex){ return false; }} g修饰符会忽略非法字符,y修饰符不会,这样容易发现错误. 正则表达式的复制在ES5中可以通过给RegExp构造函数传递正则表达式作为参数来符之这个正则表达式 12345678910var rel1 = /ab/i, rel2 = new RegExp(rel1); //在ES5中,此时rel2只是rel1的一份拷贝.但如果给RegExp构造函数提供第二个参数,为正则表达式指定一个修饰符,则代码无法运行. //ES5中报错,ES6中正常运行 rel3 = new RegExp(rel1, "g"); //在ES6 中 console.log(rel1.tostring());// "/ab/i" console.log(rel2.tostring());// "/ab/i" console.log(rel3.tostring());// "/ab/g" flags属性在ES5中如果想获取正则表达式的文本,可以通过source属性,但是如果想获取使用的修饰符,就需要tostring()来获取输出的文本. 12345678function getFlags(re){ var text = re.tostring(); return text.substring(text.lastIndexOf("/") + 1, text.length);}//tostring()返回值为"/ab/g"var re = /ab/gconsole.log(getFlags(re)); 为了简化这一过程,ES6中使用了flags属性,它与source属性都是制度的原型属性访问器.对其之定义了getter方法,这极大的简化了调试和编写继承代码的复杂度.ES6的版本中,访问flags属性会返回所有应用在当前正则表达式的修饰符字符串. 1234let re = /ab/g;console.log(re.source); //"ab"console.log(re.flags); //"g" 模板字面量 模板字面量(前称模板字符串)是允许嵌入表达式的字符串字面量.可以使用多行字符串和字符串插值功能. ES6模板字面量语法支持创建领域专用语言(DSL,通指为某些具体且头衔的目标设计的语言).它比ES5及早期版本中的解决方案更安全. ES6模板字面量这个扩展方案是扩展ECMAScript基础语法的语法糖,其提供一套生成/查询并操作其他自然语言里内容的DSL,并且可以免受注入攻击.例如, XSS, SQL注入等等. 实际上ES5中的方案缺少许多特性,为ES6通过模板字面量的方式进行了填补: 多行字符串 一个正式的多行字符串的概念 基本的字符串格式化 将变量的值嵌入字符串的能力 HTML转义 向HTML插入经过安全转换后的字符串的能力. 基础语法 使用反撇号(`)替代了单/双引号.在不包含占位的情况下和普通字符串无差别. 123456\\在模板字符串中使用反撇号可以使用\转义符,而不需要转义单双引号.let message = `\`Hello\` world!`;console.log(message); // "`Hello` world!"console.log(typeOf message); // "string"console.log(message.length); //14 模板字面量中可以包含特定语法(${expression})的占位符.占位符中的表达式回合周围文本一起传递给一个默认函数,该函数负责将所有的部分连接起来. 如果一个人模板字符串由表达式开头,则该字符串被称为带标签的模板字符串,该表达式通常是一个函数,他会在模板字符串处理后被调用,在输出最总接过钱,你都可以通过该函数对模板字符串进行操作处理. 多行字符串为了表示多行字符串,ES6之前的版本都是自行插入\n 1234567891011121314151617181920//方法一: 插入\nconsole.log('string line 1\n +string line 2');// "string line 1// string line 2"//方法二 依靠数组或字符串拼接var message = [ "Multiline ", "String"].join('\n')// "Multiline// string"//方法三//或者利用JS语法bug达到同样的目的,不推荐console.log('string line 1\n \string line 2');// "string line 1// string line 2" ES6中使用模板字面量对多行字符串的表达进行优化 123456789101112//换行要小心缩进,缩进会被保留let message = `Multilinestring`;console.log(message); //"Multiline //string"console.log(message,length); // 16//使用缩进之后使用trim()移除缩进的方式let html = ` Title`.trim(); 字符串占位符 字符串占位符功能是模板字面量与普通字符串的真正的差别.在一个模板字面量中,你可以把任何合法的JavaScript表达式嵌入到占位符中并将其作为字符串的一部分输出到结果中. 占位符${(expression)},(expression)可以使用任意javascript表达式替换. 1234 let name = "Nick", message = `Hello, ${name}.`;console.log(message); //"hello,Nick." 之后的message会一直保持这个结果. 标签模板 一种更高级的使用: 使用代表签的模板字面量.所谓的标签就是在模板字面量中第一个番茄好前标注的字符串 12//应用于模板字面量"Hello world"的模板标签是tag.let message = tag`Hello world!`; 定义标签标签可以是一个函数,调用时传入加工过的模板字面量各部分数据作为参数,必须结合每个部分来创造结果.第一个参数是一个数组,包含Javascript解释过后的字面量字符串,它之后的所有参数都是每一个占位符的解释值.函数可以返回处理好的字符串,或者它可以返回完全不同的东西,甚至不一定是一个自符串标签函数通常使用不定参数特性来定义占位符,从而简化数据处理的过程.函数名可以替换成任意名字. 123function tag(literals,...substitutions){ //返回一个字符串} 123let count = 10, price = 0.25, message = passthru`${count} items cost $${(count * price).toFixed(2)}.` 为了进一步理解传递给tag函数的参数.如果有一个passthru()函数,那么作为一个模板字面量标签,它会接受三个参数: 首先是一个literals的数组,包含以下元素: 第一个占位符前的空字符串(“”) 第一/二个占位符之间的字符串(“ items cost $”) 第二个占位符后的字符串(“.”) 下一个参数是变量count的解释之,传入参数位10,它也成为substitutions数组里的第一个元素 最后一个参数是(count * price).toFixed(2)的解释值,传入参数位0.25,它是substitions数组里面的第二个参数 需要注意的是,literals里的第一个元素是一个空字符串,这确保了literals[0]总是字符串的始端,就像literals[literals.length -1]总是字符串的结尾一样. substitutionsde shuliang zongbi literals少一个,这也意味着表达式substitutions.length === literals.length -1的结果总为true. 基于以上特性,我们可以通过交替取值literals和substitutions两个数组交织在一起重组字符串. 1234567891011121314151617function passthru(literals,...substitutions){ let result = ""; //根据substitutions的数量来确定循环的执行次数 for (let i = 0; i < substitutions,length; i++){ result += literals[i]; result += substitutions[i]; } //合并最后一个literral result += literals[literals.length - 1]; return result;}let count = 10, price = 0.25, message = passthru`${count} items cost $${(count * price).toFixed(2)}.`;console.log(message); //"10 items cost $0.25." 这里需要特别说明的是substitutions里面包含的值不一定是字符串,如果一个表达式球之后得到一个数值,那么传入的就是这个数值. 在模板字面量中使用原始值模板标签同样可以访问原声字符串信息,也就是说通过模板标签可以访问到字符转义被转换成等价字符前的原声字符串.最简单的例子是使用内建的string.raw()标签: 12345let message1 = `Multiline\nstring`, message2 = String.Raw`Multiline\nstring`;console.log(message1); //"Multiline //line"console.log(message2);//"Multiline\\nstring" literals数组也有额外的属性raw(literals[0]有一个等价的literals.raw[0]),是一个包含每一个字面值的原声等价信息的数组. 12345678910111213function raw(literals,...substitutions){ let result = ""; //根据substitutions的数量来确定循环的执行次数 for (let i = 0; i < substitutions,length; i++){ //使用原生值 result += literals[i].raw[i]; result += substitutions[i]; } //合并最后一个literral result += literals.rawliterals.length - 1]; return result;}]]></content>
      <categories>
        <category>前端学习</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>ES6</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ES6-变量作用域]]></title>
    <url>%2F2019-05-29-Understanding_ECMAScript6_Variable_Scope.html</url>
    <content type="text"><![CDATA[深入理解ES6-变量作用域 最佳实践: 默认使用const,只在确实需要改变变量的值的时候使用let。在需要覆盖全局变量的时候使用var 过去,现在,将来,一代又一代,直到时间的消失 最佳实践 默认使用const,只在确实需要改变变量的值的时候使用let。在需要覆盖全局变量的时候使用var。 var声明及Hoisting机制 使用var关键字来声明变量 无论在哪里声明，都会被当成在当前作用域顶部声明的变量 声明提前，初始化操作依旧留在原处执行 块级声明 块级作用域（又称词法作用域），用于声明在指定块的作用域之外无法访问的变量。存在于： 函数内部 块（{}）中 使用let关键字声明块级元素，将变量的作用域限制在当前代码块中 let声明不会提前，因此通常把let声明语句在封闭代码块的顶部 假设当前作用域已存在某个标识符（无论是全局或函数作用域），再次使用块级标识符声明会抛出错误。 const也是块级标识符 块级作用标识符特点是声明不会hoisting，一旦执行到块外就被销毁。 禁止重声明 同一作用域中不能用let重复定义已经存在的标识符。但是如果当前作用域内嵌另一作用域，则可以在内嵌的作用域中使用let声明同名变量。 1234567891011121314//例子1var count = 20;//下面语句会抛出错误let count =40;//例子2var count = 20;if (conditon){ //不会抛出错误，内部作用域的count会屏蔽全局作用域的count let count = 40; Alert(count); //40}Alert(count); //20 const声明 和其他语言一样，const声明的是常量，一旦被设定之后不可修改，每个使用const定义的常量必须进行初始化。一旦不初始化，则会抛出错误。 const和let都是块级作用标识符 假设当前作用域已存在某个标识符（无论是全局或函数作用域），再次使用块级标识符声明会抛出错误。 无论在严格模式还是非严格模式下，都不可以为const定义的常量再赋值。一旦赋值就会抛出错误。 123456789//不能重声明， 被let声明过的不能用const声明var count = 20;let age = 10;const price = 100;//以下语句都会抛出错误const count = 40;const age = 12;let price = 200; const声明不允许修改绑定，但是允许修改值。 1234567891011const person = { name: "Nick"};//可以修改值person.name = "Greg";//不可以修改绑定person = { name: "Greg"}; 临界死区（Temporal Dead Zone） 由于声明不会被提前，在作用域外访问变量会抛出错误。即使是相对安全的typeof. Javascript引擎在扫描代码发现变量声明时，要么将它们提升至作用域顶部（var），要么将声明放到TDZ中（let、const）。访问TDZ中的变量会触发运行时错误。只有执行过变量声明语句后，变量才会从TDZ中移出，然后方可访问。 12345console.log(typeof value); // undefinedif (condition) { console.log(typeof value); //引用错误 let value = "blue";}; 循环中的块级作用域绑定 块级作用域最经典的应用场景就是在循环中，将计数器变量使用块级声明。保证一旦循环结束，，其他地方不可以访问计数器。 循环中的函数 var声明因为变量共享的问题，使得在循环中创建函数非常困难 123456789101112var funcs = [];//var声明的i被共享存储在funcs里面。执行下面操作会输出10个10for (var i = 0; i < 10; i++){ funcs.push(function(){ console.log(i); });}funcs.forEach(function(func){ func(); }); IIFE解决了这个问题，它的思路是通过强制生成计数器变量的副本，规避共享变量。 1234567891011121314var funcs = [];//每次接收到i都创建一个新的副本并存储为value foreach循环调用的时候就会输出0到9for (var i = 0; i < 10; i++){ funcs.push((function(value){ return function() { console.log(value); } }(i)));}funcs.forEach(function(func){ func(); }); ES6支持了块级声明之后，可以使用块级声明达到同样的效果。这是因为块级标识符利用了块级标识符一旦离开了作用域会自动销毁的特性。使用块级标识符声明声明计数器变量，每次循环中都会创建一个新的变量，并以之前循环中同名变量的值将其初始化。【aka.自动副本】 对于for 循环，let和const两种块级标识符是有差别的。 1234567891011121314151617181920212223242526// **********方案一**************** var funcs = []; for (let i = 0; i < 10; i++){ funcs.push(function(){ console.log(i); }); } funcs.forEach(function(func){ func(); }); // **********方案二**************** var funcs = []; //完成一次循环之后，会抛出报错。因为i被定义为常量，i++中尝试修改i的绑定，抛出错误 for (const i = 0; i < 10; i++){ funcs.push(function(){ console.log(i); }); } funcs.forEach(function(func){ func(); }); 对于for-in或者for-of循环，只要循环中不涉及对计数器变量绑定的修改，表现就是无差异。每次循环都会创建一个新的key绑定，因此每个函数都有一个变量key的副本。于是不同的函数输出不同的值。正是因为每次都会创建一个新的绑定。在不修改计数器变量的请况下。const声明也不会抛出错误。 12345678910111213141516171819202122232425262728293031323334//**************let********* var funcs = [], object = { a: true, b: true, c: true }; for (let key in object){ funcs.push(function(){ console.log(key); }); } funcs.forEach(function(func){ func(); }); //************const*********qvar funcs = [], object = { a: true, b: true, c: true };for (const key in object){ funcs.push(function(){ console.log(key); });}funcs.forEach(function(func){ func(); }); 全局块作用域绑定 块级标识符和var声明另一个很大的区别，在于他们在全局作用域中的行为。 当var被作用域全局作用域的时候，他会创建一个新的全局变量作为全局对象[我们所说的全局对象是window对象]的属性。这意味着var可能会覆盖一个已经存在的全局属性。 在全局作用域下使用块级标识符，则是会在全局作用域下创建一个新的绑定，该绑定不会成为全局对象的一个属性。换句话说，块级作用域不能覆盖全局变量，只能遮蔽它。 如果不想对全局对象创建属性，则使用let和const 要安全。如果希望在全局对象下定义变量，仍然可以使用var。这种情况创建于在浏览器中跨frame或者跨window访问代码。]]></content>
      <categories>
        <category>前端学习</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>ES6</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + GitHub Pages搭建博客教程(附带踩坑+攻略)]]></title>
    <url>%2F2019-05-04-Hexo_GitHub_Pages_Build_blog.html</url>
    <content type="text"><![CDATA[仅以此文记录我自己搭建hexo博客的过程以及踩到的坑. 本地操作系统为为Win10. 使用的hexo版本为3.0后的版本(NexT对其支持较好,2.0+版本未实验) 托管位置:github 过去,现在,将来,一代又一代,直到时间的消失 什么是Hexo? Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 选择Hexo的理由很简单. 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件 支持一键部署 有丰富的插件和主题 Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 内容物为静态网页,可以轻松的托管再GitHub上,管理和更新方便. 什么是Github Pages? Github是世界上最大的代码存放网站和开源社区.Githubpages功能的推出,让用户有机会自定义项目首页,用来替代默认的源码列表.它是一种被用户编写\托管再Github上面的静态网页. 准备工具 “工欲善其事,必先利其器” 工具类安装 下载安装npm 下载并安装Git 下载并安装Node.js Create a new repository 特别提醒:我已经拥有Github账户.如果你没有,请移步官网注册. 这里一定要把项目名字定义成以下样式. 1{username}.github.io 搭建博客本地环境搭建Hexo 本机新建一个文件夹,如blog 进入该文件夹.鼠标右键选择”Git Bash Here”. 1npm install -g hexo-cli 执行上述步骤成功后,输入 1npm install 生成静态页面,启动本地hexo服务进行本机测试.依次执行以下命令 123hexo cleanhexo ghexo server 打开localhost:4000, 测试安装是否成功.看见页面即为成功. 关联到Github Create a New respository 安装Hexo的Git Deployer插件 1npm install hexo-deployer-git --save 本地生成静态文件 12hexo cleanhexo g 将静态文件推送到Github. 1hexo d SSH Key 使用SSH key避免执行Hexo d部署时频繁的密码输入. 测试是否有已存在的SSH key任意位置打开Git Bash 1cd ~/.ssh 本地生成密钥 如果没有,那么我们在本地生成密钥.输入的邮箱是github注册邮箱. 1ssh-keygen -t rsa -C "your_email@example.com" 根据提示按下三次回车.可以看到以下文字则表示密钥生成成功.(生成的id_rsa.pub文件默认在系统盘个人文件夹下的.ssh文件夹中.) 123 Your identification has been saved in ~/.ssh/id_rsa.Your public key has been saved in ~/.ssh/id_rsa.pub.The key fingerprint is: 设置GitHub项目的deploy Keys,粘贴进去就好了. 测试配置是否成功 1ssh -T git@github.com 出现以下样式的配置则表示成功 12 Hi username! You've successfully authenticated, but GitHub does notprovide shell access. 修改部署协议为SSH 进入blog文件夹,使用记事本类工具打开_config.yml文件,设置deploy属性. 1234 deploy:type: gitrepo: git@github.com:chengjianhua/chengjianhua.github.io.gitbranch: master 设置域名 购买域名(我用的阿里云购买,大家可以根据自己的喜好) 域名备案 设置DNS云解析(域名解析生效需要时间,我直接隔天查看了) 依次进入本地文件夹Blog->source,新建一个文件名为CNAME 执行”cgd”操作将CNAME文件提交到服务器上 123hexo cleanhexo ghexo d 使用网址访问是否正常. Hexo使用指南(Next)Hexo主题设置(Next) 下载主题我使用的是star数量最多的Next主题,你也可以访问主题列表选择自己喜欢的主题. 进入blog页面,Git Bash here输入以下命令以下载next主题.(我是无脑最新,稳定版下载请访问Next官网查找最新稳定版本) 1git clone https://github.com/iissnan/hexo-theme-next themes/next 下载完成之后,会在\bolg\themes中看到next 文件夹. 找到blog底下的_config.yml文件,修改theme 1theme: next 执行“cgd操作” 提交到服务器.如果你想在本地查看,那执行完cg操作之后,使用 1hexo server 启动本地服务,在浏览器中使用localhost:4000查看本地页面. Next 设置语言 实名感谢Hexo支持中文. 修改blog下的_config.yml文件中的language 语言 代码 English en 简体中文 zh-Hans Français fr-FR Português pt 繁體中文(Hk) zh-hk 繁體中文(tw) zh-tw Русский язык ru 日本語 ja Korean ko Next更多使用说明可以查看Next官网.或者期待我的不定期更新的日常 遇到的坑与解决措施SSH 协议设置不生效SSH协议传输设置最开始使用网上的 1234567891011121314 #切入到包含 .git 文件夹的文件夹 cd .deploy/ #查看当前的传输协议 git remote -v origin https://github.com/USERNAME/REPOSITORY.git (fetch) origin https://github.com/USERNAME/REPOSITORY.git (push)#修改 https 协议为 ssh 协议 git remote set-url origin git@github.com:USERNAME/REPOSITORY2.git#或者 git remote add origin git@github.com:username/username.github.io.gi 然而并没有生效,最后使用了上文所述SSH设置方法,才生效.原因未知,google了以下,也有很多人和我一样. localhost正常,部署后自定义域名访问为404或空白 localhost页面正常,然而部署到github之后页面不是空白就是404 查看github上面的文件,发现index.html文件中都是空白,怀疑是提交插件安装有问题.我重装Git Deployer插件后正常.具体猜测是因为第一次装该插件有依赖包版本不正确.回滚数个版本仍异常,干脆卸载重装,重装后正常. Localhost正常,部署后页面没有无主题样式,只有文字. 看了下页面的html文件,主要是加载的script位置不正确.具体的配置跟blog下的_config.yml有关. 修改期中url与root设置后正常.(切记冒号后要有空格,不然编译出错) 12url: https://github.com/iwits/iwits.github.io/root: /]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>环境搭建</tag>
        <tag>GitHub pages</tag>
        <tag>NextT</tag>
      </tags>
  </entry>
</search>
